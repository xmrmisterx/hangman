Below are our unfiltered thoughts during this assignment. We also attached a copy of the finished code, with most lines commented for clarity, at the end of this README...




Alright, so hangman, which we actually know the rules of. I guess that's a good start, as opposed to mastermind lol. In this game, a word is chosen, and the player has multiple attempts to guess a letter of the word. Each time a correct letter is guessed, it will be placed into the mystery word, slowly forming the mystery word. If a wrong letter is guessed, normally a rather morbid drawing of a hanged man occurs, each wrong letter resulting in the drawing being more fleshed out. This equates to 8 guesses for the player until the game is over. The player can at anytime try to guess the word, and if right, or if all the letters of the mystery word are guessed, the game ends. If the player guesses the word and gets it wrong, it's considered the same as a wrong letter guess. 

There is a text file that the assignment wants us to use, and when the game starts, a random word between 5 to 12 characters should be picked from that file. So... how would we do that? How do we even load another file? I think we've done this before during the javascript part and we had to write the html. We would reference the javascript and css files, but how do we actually get the code to pull out a random word with certain traits from this list? That sounds like something a parser would do. Now, we had the csv file from the event manager assignment, so how did we read that file? How was it even accessed first of all?

Ok, so looking at the previous event manager assignment, we see this code "contents = File.read "event_attendees.csv". Basically we need to put that file inside our hangman folder, and we can access it by just doing "File.read'[filename]'. Alright, so let's try that. Wow, the code is alot of words, and the format is pretty bad. How do we make it to an array of lines again? We're gonna use this code as a guideline "lines = File.readlines "event_attendees.csv"
lines.each do |line|
  puts line
end" Ok, so that's better. Basically we used the exact same code as this, but instead of putting the csv file in quotes, we put our txt file, and we get each word separated by a line, much easier to read...

Now, we need to pick a random word, which tells us to use the "sample" method for arrays. However, we can sample only from words 5 to 12 characters in length. Alright, so the original document has words that we don't want in it. I think we want to filter this array into something we want. First, we need to create a words array, which is just putting the lines out I'd say, like what we just did. Then we'll create a filtered_words_array, which has words only 5 to 12 characters long. Ok, so we create a function and make our word array, now let's create the filtered words array, basically iterating through the words array and only keeping the words of length 5 or greater and 12 or less. Hmm.. thats weird, our map function to look for words greater than or equal length 5 and less than or equal to length 12 only returned 1 word, why is that. It looks like our map function stopped at the first word that matched, instead of checking every word, that's kinda weird. Let's use a 'each do' loop instead of map. Hmm... that didn't change the result, maybe instead of using return, we just put "word" so it doesnt break the loop maybe? Ok, so removing the return of "return word" gets us what we want. It's actually running the code for the whole array now, but words that are 5 to 12 letters in length are being rejected, let's double check our code. Lol, this is still returning something weird. I think our map code was wrong earlier, but map is the correct array method here, so let's use that again.

Hmmm... we are noticing something odd as we try to puts out our filtered_words_array. Each word seems to be accompanied by "\r\n", which actually means the words lengths are being artificially inflated by 4 characters each, so we have to update our code "length >=9 and <= 16". Let's try this and see what we get now. That's odd, even with the updated code, we still see words that should be in the new array get rejected. Let's take a closer look at the words in our arrays. Ok, looking at our words array, we realized that this code isn't correct... "def create_words_array (txt)
  lines = File.readlines "#{txt}"
  lines.each do |line|
    puts line
  end
end" The puts output is what we want, and that's the array we want, but we're using a do loop, which doesn't return a new array, it returns the original array, which means our resultant words array that we set equal to this function, gives us the unparsed txt file, and that is causing problems with the filtered_words_array function. So, let's change this to a map, and instead of a "puts line", just have "line" for the last piece of code, which should result in the correct words_array. I thought we double checked to see if this worked already, but it seems we just looked at the "line" outputs and not the actual words array. Wow, that didn't work. It didn't change anything. Let's try the code "puts line" instead of "line". Hmmm... our words array did update here, but it's an array of "nils" instead of the words that we want lol... Let's try the puts line inside the brackets, then a line outside the brackets? Maybe it's not saving anything bc there isn't anything after the brackets, which is where it'd save? Alright, nothing is working, how about this? We know that the puts is what we want to save right? Let's set an array equal to that? We're kinda stuck here. Let's take a little break. Let's look up the array functions again.

Let's think about this a bit. The "map" method transforms the array into something else, but that's not what we want to do. We want the original format, but in lines form? I mean, if the txt file is already an array, why do we need to convert it?  We thought the txt file that we opened up was the format, but thats a parsed format, the original format is actually a giant string with each word separated by "\r\n". Can we remove the "\r\n" from each word, then put it into a new array? I think we want to use the split method on the original txt file? Let's review the split method again. Let's try this code "words = File.read "5desk.txt"
words_array =  words.split("\r\n")
words_array" OK, that worked. The words array is the array we're looking for. I think we realize the problem now. When we opened up the txt file originally, we thought that was the way the file is, but that file has actually gone through the filtering from the editor used to open it. It's original form is just a giant string of words with "\r\n" separating each word. So we really didn't need to  use map and create an array from the lines, all we had to do to get our words array, is remove the "\r\n" part, which we can simply do with the split method on the original string. 

Now that we have a proper words_array, let's continue with the next function, creating a filtered words array that has only words between 5 and 12 characters in length. First, let's rewrite our create_words_array using the code we just used. Ok, so that works now. Now let's move on to the filtered_words_array. We run our create_filtered_words_array function with the now correct words array, and it does give us an array of words that are between 5 to 12 characters in length, but the spots where the words were removed, there is a "nil" element. I guess this isn't a problem if we're gonna iterate through it and sample no.... it will be problem. We don't want nil to be an actual option. We know there is a way to remove all nil from an array, but let's figure out why it's returning nil in the first place. Is it bc our else statement having  a puts? Let's remove the else part. We thought the code would just select the words matching our length limits, but it added nil elements lol. That didn't remove the nil elements. I guess we'll just have to find that method that removes it, but before that. Can we express the length range in a more elaborate way, using ".." Let's try that. Lol, we can't find the website we referred to last time that talks about ranges, so let's look at the event_manager assignment where we used ranges. Ok, so the format is "if (range) === value" and this means if the value is between that range. Let's try it out. Yes! That worked. It's a much more elegant way to say if a value is between a range than setting the ranges min and max.

Alright, so back to our create_filtered_words_array function. We need to filter it and remove all the nils. Looks like there is a function for that but... we read something interesting. One post stated that if we are getting unexpected nils, then our logic is faulty and we should look into it. He gives an example that is very close to what we are doing. This might generate unwated nils 
"[1,2,3].map{ |i|
  if i % 2 == 0
    i
  end
}
# => [nil, 2, nil]"
so use this instead 
"[1,2,3].select{ |i| i % 2 == 0 }.map{ |i|
  i
}
# => [2]"
Basically we need to select for what we want first, before mapping. Let's try that in our code. Ok, yeah, that did work. The code we used is "def create_filtered_words_array (words_array)

  words_array.select {|word| (5..12) === word.length}.map {|word|
    word
  }

end
" and basically we select teh words we want, and call map just so that it returns an array? I'm assuming select doesn't return an array, bc map here following select doesn't actually do anything. I think it's only purpose is to have the function return an array. Wait, reading about the array methods it says that the "select" method does return a new array, then why are we even using "map"? Let's remove the map portion of our code and see what happens. So that's interesting. The "select" method worked by itself, without the map method tagging along. I guess we just picked the wrong method from that start, but... we're comfortable with "map", not so much with "select" which is why we chose "map", but it looks like select actually discard the values we didn't want, whereas map put those values in, as "nil" elements.

Ok, so we have our 5 to 12 character word arrays now. Now what? Can we actually start making the hangman game? I think we have to code the choose a random word part first, then we can begin. Lol, that was fast, we just called the sample method on the filtered_words_array and it worked, as expected. Alright now what, let's review the rules of the game and decide on our classes and start some pseudocode.

Alright so let's first consider what needs to be displayed. We aren't going to use a hangman drawing, bc it's kind of crude and isn't exactly great at telling the player how many guesses are left, instead we'll just display a counter, something like a "guesses_remaining:" counter. For the word, how will we handle the mystery word? At the start of the game, we want to display on the board a number of underscores equal to the amount of letters in the word, then fill in the underscores with letters as they are guessed. So, we can just display the mystery word, and the guesses counter, as a puts I'd say, definitely the guesses counter, the mystery word, has to be dynamically generated each time depending on the length of the word, and how many correct guesses. I think that's enough for the display logistics, but I really think we should've started with the pseudocode, followed by the classes.

Alright, let's pseudocode out how we want the game to flow... 1) We start by asking the player for their name... actually, this isn't necessary, since unlike tictactoe, there's only 1 player here, just call the player "player", I don't think we need to get their name 1a) So the game starts off, a random word is chosen, and the board displays underscores for how many letters are in the word 2) Next we prompt the player to pick a letter (we have to make sure that whether they pick "a" or capital "A" that it's the same result, and if they pick something not a letter, to give some sort of error message here) (also note that the player can also try to guess the word here, not just a single letter... actually, this is part of the real game, but it isn't explicitly something the assignment tells us to do, so I think we'll just skip this part. I mean, guessing the letters, and the word, is almost the same difference, if you know the word, you can guess enough letters to spell out the word) 3) After the player's input, the game board will show up again... If there is a correct guess, the letter will be placed in the appropriate spot of the mystery word, then we'll want to display the letters that have been guessed with a "letters_guessed_so_far:" counter. We will need to update a "number_of_guesses_left:" counter to tick down if the guess is wrong, and stay the same if the guess is right. 4) We want to loop the puts to "pick a letter" and the updating of the board until the player has no guesses left, or all of the letters of the mystery word have been guessed, in which case the game is over. 

Alright, those look like pretty detailed steps of how the game will go, now... What will the classes be and what will the objects be? I think they'll be a player class, and a board class, and a game class. The player class... hmmm... there's only one player, maybe we don't have a player class. What about the board class, is there reason for a board class? I think the mystery word and all the counters, can be in the board class, and I think we definitely need a board class. Now what about the game class? This is our main class, and we'll definitely need the game class. There should always be a game glass for any game, as that's where we'll put logic to see if they game should continue, or if it's over. Alright, so 2 classes, board class and game class. 

**Let's flesh out the psuedocode a little more, by using possible functions for each step of the pseudocode, and seeing what class is invovled in each step... 1) random word is chosen from our filtered words array => choose_random_word function (game class) 2) board fills up with blank lines corresponding with the number of letters in the word => display_word (board class) 3) prompt to pick a letter => pick_letter_prompt (game class) 4) convert letter to lowercase/uppercase depending on where the letter is in mystery word and what the player typed => convert_letter (game class) 5) if player input something that wasn't a letter, display error message => not_a_letter_error (game class) 6) Update the letters guessed display => update_letters_guessed (board class) 7) If letter guessed is correct, display it in the mystery word => display_word/update_word (board class) 8) If the letter guessed is wrong, display a message saying so => wrong_letter_message (game class), then tick down the "number_of_guesses_left:" counter, which will start at 8 => update_number_of_guesses_left (board class) 9) If there are no guesses left => check_number_of_guesses_left (game class), or if all the letters have been guessed => check_if_word_guessed (game class), then the game is over => check_if_game_over (game class). If the player lost => display_loser_message (game class) and if the player won => display_winner_message (game class). 10) We need to put the ask a letter prompt and everything afterwards into a function called game_loop (game class) and break this loop if the game is over (game class).**

Ok, that looks pretty good. Now let's think about this a bit... What objects are there, and what class will they be initiated in? So we'll have the board class and the game class. Now that we think about it, do we even need a board class? It seems everything is handled by puts, but the possible objects could be the mystery word and all the counters that keep track of letters guessed and guesses left. There really isn't a game object, but I think the word should be initialized at the start of the game. What objects will have to be shared between classes? I think the letters guessed need to objects that both classes will need to have access to. The mystery word as well. Now that we think about it, yeah there needs to be a board class to hold the guessed letters of the mystery word as well. Let's start coding these classes I think we've done enough precode prep.

Alright, we've added all our functions so far into a Game class, and created a choose_random_word function in that class, now let's run the code. Alright that worked well with no hiccups, now what. We're gonna need to create a Board class and display the number of letters in the word as underscores. We realized as we were about to initialize our Board class that we need to initialize the Game class. That got us thinking about what sort of objects we need to initialize, and so far, we're thinking we need 3 objects: our word (equal to choose_random_word function), the board, and the letter guessed. We set all these equal to instance variables so we have access to them inside our Game class. We're having problems deciding what to initialize in our Board class, if anything, and if we initialize the board, what does that even mean, what is on our board? Let's focus on what the board is gonna do so we have a better understanding of what needs to be initialized. We need to make this display_board function in the board class, which should have a parameter of the word, and maybe that's what we will initialize.

Ok, so we want to create an underscore for each letter in the word, which can mean to create underscores equal to word.length. We can loop through each letter in the word, and create an underscore, and this might give us a display we want, but what happens when there's a letter guessed in the word? How would that work out? No, we don't want to create an underscore, what we want to do, is create an array of nil objects for each letter of the word, just like in the tic tac toe assignment. Arrays are good for holding data, and we can change that data, or keep it the same. So, when a letter is guessed, we can compare our board array to the word array, vs the letters guessed, and place the letter in our board array if the letter guessed matches our word array. We can also put a condition when looping through these arrays, that if the array is nil, to put an underscore there, but if the array has something, or the else statement, we can do "cell.to_s" and it keeps the current letters... Yeah, I think this should work, let's try it tomorrow.

Alright, the array within an array code was not as easy as we remembered lol. First, we tried "Array.new(word.length) {nil}", which instead of giving us 5 arrays with 1 nil element in each, it gave us 1 array with 5 nil elements. Then we tried "Array.new(word.length) {Array.new(nil)}",which gave us an error about integer and nil conversion. The code that actually worked is our current one "Array.new(word_length) {Array.new}", which gives us an array of word length arrays, and the elements are nil elements by default. It's gonna be tricky trying to access each letter in our word represented by the arrays, bc they are embedded in a large array. Alright, now let's try to print out the underscores. This should be just like printing out the dashes in tic tac toe. We're gonna try the exact same code like in tic tac toe, but replace the dashes with underscores. Theoretically it doesn't seem like we need to iterate through every row and cell, but let's try it and see what happens.

We coped the render function from tic tac toe, but it just gave us our blank arrays. Let's first see what's in our arrays? We try the "[0][0]" coordinate and get our first array, so that's good. Let's try [0][2] and [0][4]... Lol, that added some nil elements and made elements 1, 3, and 5 in the first embedded array the values we set. However, they were all in the first array, and we wanted to access the 3rd and 5th arrays (which will correspond to our 3rd and 5th letters), so let's try [0][0], [2][0], and [4][0] instead. Ok, so that worked. It seems we will access our letters by using [][], where the first coordinate is the position of the letter, 0 being first position. The second coordinate will always be 0.

Now that we know how to access our board, we need to go back over the looping code and find out how to our board to print underscores for those arrays we want. Let's try putting in the "puts" like in tic tac toe. It seems the puts spaced out the arrays vertically, but it's still not printing anything. Can we check if our actual elements are nil? Let's just type out the board coordinates, and don't set them, and see what shows up. Lol, that didn't do anything. What about istead of the if statement, we just said "print("_")", what happens then? Hmmm, stil blank arrays. What if we removed the rows and elements and just looped through the row? That didn't do anything... What if we used puts instead of print? Wow.. that actually printed out something! 5 vertical underscores... Now we're getting somewhere! So apparently puts is what gives the vertical spacing, so it makes sense why there were 3 puts in the tic tac toe code. We realized all along that none of the code so far displayed anything, we were just looking at this "=> [[], [], [], [], []]" which is our array being returned. We thought all this time the blank arrays were being printed lol, but actually puts was the only code to do anything, and it nearly did it right. Now... how do we get it to puts horizontally instead of vertically?

Let's try our current puts code, but use print instead. What does that do? When we used the code "p("_")", it pretty did the same thing as puts, but the quotes were there around the underscore, and obviously we don't want that. I think the problem is maybe that we're printing in the wrong place? Let's do the loop inside a loop code again and see what happens. Doing a row loop and a column loop, actually doesn't do anything. Before we continue with this, I think our arrays don't have nil items? Let's try this code "Array.new(word_length) {Array.new(1)}" and if the the "(1)" gives us nil objects inside the array (we want to keep that code that says if array is nil, to put underscore). Oh wow, that actually worked. We thought "Array.new" is an implied "Array.new(1)" but the parantheses version has nil objects inside the arrays, the version without parantheses is just an empty array. Ok, now that we have our nil arrays, let's go back to our code, and use the tertiary operator to print an underscore if nil, or cell.to_s if not... This is interesting, we get 5 nil arrays printed out, the interesting part being that they were in the left to right format that we wanted, instead of top to bottom. Let's try the same thing but use puts? Hmmm. it doesn't seem like we can use puts. It's not compiling with puts. Let's do the puts code that we started off with, it was the closest to what we wanted, but it went vertically instead of horizontally. Hmmm.. same thing. Let's try the double loop with puts? Not sure if we've tried this already lol, but let's do it. The double loop actually has the same output as the single loop. Man, we're kinda stuck here. How are we supposed to display this board? It's funny bc with the TicTacToe we had problems with the display being horizontal, and now we can't make our display horizontal. What happens with print again? Woah, that actually did it. We noticed that there is no spacing between the 5 underscores, but "print ("_")" actually worked. Is there a difference between print and p? Let's try p again. Interesting , so "p("_")" does the same thing as puts, but keeps the quotation marks. Print apparently does something completely different, and thats what we want.

Let's go back and try "print" but use it in the single loop, maybe it works here too. Yeah, so it seems we don't need the loop within a loop here, as the single loop works fine. Let's try the if statement on this single loop, it should print out the exact same thing since all our arrays are nil elements. That's odd, it displayed 5 nil arrays. Let's try it with the loop within a loop, since we found that this code outputs the same thing. Maybe it's the second loop arrays that we are checking for nil elements. Interesting, so with row loop into the cell loop code, this outputs what we want, 5 horizontal underscores. However, we can't check if this ternary operation (not tertiary lol) works if something is printed. Let's put a letter somewhere in these arrays. Putting "@board[2][0] = "o"" in our initialize function renders a board of "_ _ o _ _", which means our if function to not put an underscore if the array isn't nil, is working. Alright so everything checks out but... The 5 underscores are too close together it makes it very hard to see, is there some way to add a space between them? Isn't this easy, just print an underscore with a space lol.
So, instead of "print("_")" we used "print("_ ")", with a space after the underscore. This almost worked, as we used it with a letter for the middle array again, and that letter didn't have a space, so the word spacing looked off. As long as we have our letter array elements with an extra space, the format looks good and consistent. Hopefully this extra space doesn't create problems when our code gets more complicated...

Alright, so I think we have the display board working now. However, we haven't tested for anything else besides 5 letter words. Let's try a 12 letter mystery word and see if anything odd happens. Oh yeah, simply changing the word length parameter to 12 gave us a new board of 12 letters, and everything looks good here. The random letters that we've put in look good, and are in correct position to the underscores, and the underscores all have a space next to them, making it alot easier to tell how many letters are actually in the word. Before we forget, let's google the difference between "p" and "print". It says that "puts" creates a new line, whereas "print" prints things on the same line. With regards to "p", rubyguides.com says it's more useful for debugging.

Ok, so it looks like our next steps are to prompt the player for the letter of their choice, then convert that letter so that case doesn't matter, then put the letter on the board if it matches a letter in our mystery word. Actually looking over our code, there's a disagreement between the Board class initialize method, and the Game class initialize method. We have a Game class initialize of 3 parameters, but we aren't actually creating a new "game" object with a "Game.new" that has parameters? We need parameters right? Let's make sure these 2 classes work together so far. Yeah... the way we wrote the initialize for our Game class, we need 3 parameters, including the word and letter, which we don't have as parameters? Let's try putting in generic parameters of word, letter, and board? As we expected, the generic variables for parameters doesn't work. Maybe word and letter should be in the initialize of the Board class? I mean, they are more part of the board than the game? Doesn't it seem the code is much cleaner if the game doesn't have parameters for an initialize? Let's go back to our tictactoe code and see what we did. Yeah, looking at our tictactoe code, there are no parameters in the initialize for either the Board class or the Game class. We just set @player = player1 or whatever, but we didn't need them as the parameters in the initialize function.

Looking over our Game class... yeah, we want to define instance variables for the word, letter, and board, but we can just define it in the body like in the tictactoe assignment? We don't need to actually put them as parameters? Alright, so instead of putting board, word, and letter as parameters, let's just define those instance variables to what we want. So "@board = Board.new...", "@word = ...", and "letter = ''", but we'll keep the Board class initialize bc that one actually makes sense. Now let's see if this works. Ok, this worked. When we used "game = Game.new" then typed in game, we got a definition for @word,@board, and @letter, which is good, that means they were defined in the initialize function. However, we did call a @board.render in the initialize function, but the board didn't render? We weren't sure if we could call a method of another class in our game class, so we expected either our board to be rendered, or an error message saying nil method or something, but instead it didn't do anything. Why didn't our board render, or at least give us an error? Maybe we can't render from the Game class? Let's try adding the board.render to our Board class' initialize. If this works, that's great, we have the intro figured out, but what if we want to render the board after each letter is guessed and we can't call them from the Game class lol. Hmmm.. now that way gives us an error saying "render" is not defined. How did we do this in tictactoe again?

Interesting, this code is exactly the same in tictactoe. The only noticeable difference is that, in tictactoe we had the board class first. Maybe we are trying to access render when it hasn't been defined yet bc it's below the Game initialize code? That doesn't really make sense bc the code compiled everything before processing the "game = Game.new" code, but let's try it and see if that changes anything. Alright, so we moved the Board class to the beginning, above the Game class, and run the code that didn't work before, with the Game class initialize function having a "@board.render" after creating the @board. Nothing changed. Now we're questioning ourself. Does this @board.render code work in the initialize? Bc we've been testing it outside the code. Let's just try the board class by itself and have it initialize and then render in the initialize. Interesting, we get the exact same rejection as when we tried this same thing above, it says render is not defined. Ok, now that we think about it, this actually makes sense. When we do "@board.render" our board is defined as just an array in the Board initialize function, so obviously that isn't defined. When we define @board in the Game class, @board is defined as an object of the Board class "@board = Board.new(@word.length)", therefore it can class the methods from that class. Which begs the question why doesn't @board.render from the Game initialize work? It's not giving us an error, nor is it rendering the board, which is very weird. Let's look at our tictactoe code one more time. This is very weird, the codes are exactly identical, and the other function isn't giving us an error. How do we debug this? Put some prints in the render function? Why is it not rendering? The code must be running, since there's no error, and it looks like the word.length parameter works, bc the resulting board has the same number of arrays as letters in the word.

Yeah, I think there might be something wrong with our render function. Put some debugs in there. Ok, we're gonna put a puts after our loop saying the render function is done. Now let's run the render function in the Game class initialize function and see if it's actually rendering or not. WTF, our board did render. That was entirely unexpected. Why did it render? We've ran that exact same code without the puts like times and nothing happened. The puts was just for debugging purposes, but did it actually resolve some problem? Or maybe we reopened terminal today and fixed something in the memory? Let's try again without the puts. This is so weird, we remove the puts and now it's not showing our board again. "Puts" actually changes the display for some reason. Let's just put a blank puts at the end of our loop. Now that we think about it. That was another difference between this code and the tic tac toe code, there were random puts in that code (we thought those were there to make the tic tac toe board go vertically, but apparently it helps display the board somehow). Can we google this, it's so weird and we don't understand. Let's try our code first and see if it works then google. Yeah, that worked again. Just putting a random "puts" with nothing else, got our board to display, so weird. Googling only says puts adds a newline. Not sure how that relates to our display. Was it displaying on some previous line we didn't see before? So I guessed we fixed the board display, even though we don't understand how exactly it was fixed.

Alright let's go back to our tasklist. The next step is to ask the player for a letter. We create a function in the Game class to do this, and set @letter equal to gets.chomp. Alright that seemed to work pretty well. Now... we need a filter function for the player's input, bc sometimes it's not a letter, and sometimes it's the wrong punctuation. The first thing to filter is if the letter is actually a letter, and not some number or random string. We want to use the range and variable between notation that we've used for the last few comparisons we had to do, so let's try this code first, just for the lower alphabet range "if (a..z) === letter". Lol, we get an error saying 'a' is undefined. Does (a..z) not work, let's try the uppercase version (A..Z). This one has a different rejection, 'uninitialized constant'. Hmmm... I think this one is saying A is not a constant. Wait a minute, we forgot to make these string form! Ugh, let's try it again as a string. We thought maybe "a..z" just doesn't work as a range, but we've seen this code before in other people's codes, so I think the problem is we forgot to quotes surrounding the letters to denote that they are strings, that we're talking about a to z of the alphabet. Ok, so we tried the letter "p" and got it to say the correct puts, now let's try capital "P". Lol, the capitalized letter got the puts that it wasn't a letter either, which isn't correct. Let's rerun this code to clear out any variables and try again, we weren't expecting that result. It's still not recognizing letters. Maybe we can't access these letters like this? Let's put the ask for a letter and the filter letter both in our initialize function and see if that works better. Still not working. That's pretty weird, it's not recognizing our letter as a letter, maybe the alphabet range doesn't work? But we've used this alphabet range before lol. Wait a minute, what if instead of doing the range like this "'a..z'" we did it like this "'a'..'z'"? Is this the problem? Yes, that did the trick. Honestly, we didn't expect this first part to take so long long, but there is some tricky code here that we kinda just have to learn as we code it seems. We knew the correct method of doing it, just didn't have the right syntax. Alright, now that we're able to test for letters, let's combine the upper and lower case if statement? Actually, I don't think we want to do that, since we might want to change the case of the upper or lower case depending on what case it is.

Set up the rules to determine whether we should change the case of the inputted letter, then set @letter equal to the filtered letter. Afterwards, figure out how to check to see if the letter is in our mystery word, and if so, put it in the exact same spot on our board as it is in the mystery word. Actually, the case of the letter, and the matching that letter to our mystery word, are actually very similar problems. We want to find this letter in our mystery word, then return that letter, then we want to set the board coordinate equal to the array coordinate of the mystery word? Our board coordinate, assuming x is the coordinate of interest, is "@board[x][0]", where "x" will be the index for our letter in the mystery word array. So, that means we need to create a mystery word array first of all, probably using something like "@word.chars" to break each letter of the word into elements of an array. We can keep doing this, but there really isn't a point. Let's just create a function that does it one time, and set it equal to a variable? Actually I think we will use this alot, let's add it to our Game initialize and set it, something like "@letters_array = @words.chars". We get an error for "chars" method lol, is it "char" instead? What "char" says undefined method too. We google and it is "chars", and test "seesaw.chars" and it worked, so why is this code not working, kinda weird. We look over our code and it turns out we have a "@word" defined, but then we used this code "@words.chars" in which @words is not defined lol. So bad. We change the plural words to word now, I think that was an autosuggestion though, maybe not our fault lol. 

Ok, good, that worked and now our letters_array is showing up properly. Now, we can loop through our letters array for each letter, and return that letter as a filtered letter. Then we can use that new @letter (or filtered letter) and get its index in the letters array, then set the corresponding board array equal to @letter. This could all be inside a display letter function or something. Ok, so our filter letter function seems to be working. Now, we haven't tested the case where instead of giving a letter or number, which so far works like we intended, we give a string. What if we give a string of letters? How does our code respond to that? We thought maybe our code would respond fine to it, but it actually recognized a word we put in as a lowercase letter, which isn't correct. So, let's add a stipulation to our filter letter method, something like the "letter" can't be more than 1 letter long "letter.length == 1". We put it after our main if statement in the filter_letter function, so now there's alot of if statements in that function and it looks a little convoluted, but the code is what we want, so we'll keep it like that for now. Lol, it doesn't compile bc we added the extra if statement but didn't add an extra end to the class, yikes. We have to remember to match up all the ends in the functions, if statements, and classes. Actually now that we think about our filter method a bit, we don't really need a separate if statement for capital and lower case, just put it in the same if statement and use "||" the or notation. Ok, so the stipulation for the letter being only 1 character in length solves the string input problem. Now back to what we were thinking. The alphabet check, capitalized or not, just tells us if the letter is actually a letter, so we don't really need to know if the player's guessed letter matches the uppercase or lowercase alphabet. This means combining the upper and lowercase alphabet checks into a single if statement with an "or" in it should be fine. However, the next step checks to see if the letter chosen is in the letters_array, and there is no check here for the upper or lower case form of the letter, but there should be. Using the randomly generated word of "outcast", we see that "O", or capital form of the letter "o", doesn't result in a match when "O" is compared vs the "outcast" letters, whereas uncapitalized "o" shows their is a match. We want the player to be right when they guess "O" bc it is in the word, just not capitalized.

Update our filter by combining the checks for upper and lowercase alphabet letters with an if or statement, then change the code so that it checks the letters_array for both the upper and lowercase version of the letter guessed, then returns the capitalization that is in the letters_array. Ok, so the first part worked as expected. The or statement has the same result, but is much more clean code. Now, we need to check the letters array for the capitalized and noncapitalized version of a letter, then return that version of the letter. Currently our code is "if character == letter" so I think we can just do 2 checks and use an "or" again to check both upper and lower case versions, so something like this "if (character == letter.upcase) || (character == letter.downcase)". Now when we check and the case of the letter guessed is wrong, it should still return that letter. Alright good, so the upcase and downcase code worked well. That was suprisingly error free. Now, how do we return the capitalization from the letters array. What if there are multiple instances of the letter, and both upcase and downcase versions? Looking over our functions, we should be separating these checks into multiple functions first of all. Maybe break down our current "filter_letter" function into 2 separate functions: "valid_letter?" and "letter_in_word?". Then, we can create a third function "place_letter", which will search for all instances of the letter in the word, and return the corresponding letter case from the array, and the index to match the word board index.

Alright, we created the valid_letter? and letter_in_word? checks, now let's test them. This code is taking a while to compile now ugh. This compiling speed really slows down our code writing and debugging. Maybe next time just isolate the function we want to test, instead of running the whole code, it's starting to take too long to compile. Looking over our code while it compiles, we realize we don't need this part "letter = @letter". We had put letter in there as a temporary placeholder for @letter, bc we were going to change letter and then set @letter equal to it, but these checks don't involve that part, so we can remove this part of the code. When actually don't need to even do this now, since this will be in the "place_letter" function, and it doesn't involve changing @letter I don't think. Also, I think we should change our variable "@letter" to "@letter_guessed" to make it clearer. Ok, it's finally done compiling and both boolean checks worked, so that's good, but it did take a while to compile. We did change some of our variable names, so make sure nothing goes wrong when we try to recompile. Also, make sure we check if letter is valid before checking is letter in word, bc if the player guesses a string, it's possible it could be found in an array of the word and we'll give wrong results.

Ok, now let's create our "place_letter" function. I think this function could be a part of the Board class instead of the Game class functions we've been adding. We want to search for all instances of our letter(upcase or downcase) in the letters array, then return the element (and index) in the letters array that matches our letter, and place it in the word board matching the letters_array index with the word board index. When recompiling, check the boolean functions and test all the variations of input. Ok, our new boolean variables worked fine. Now back to this place_letter function. It seems we want to return 2 linked values at a time, the element and its index, so maybe we should consider a hash to put that info into? Yeah, I think a hash is the simplest solution. Ok, so we create the function and go to test it, but this code "place_letter_hash [:letter] = index" results in this hash "{:letter=>1}", but we don't want the "letter" we want the value that letter stands for, so let's try this "place_letter_hash [letter] = index", having the letter without the colon before it. Launch school had the colon notation, but now that we look at it, we've been using the non colon form to get the result we want, not sure why they have it like that. Ok, yeah, changing to just "letter" worked the way we want, and our code does work, we are getting the "letter" from the array returned, with its corresponding index, that matches the @letter_guessed, regardless if @letter_guessed is capitalized or not. Alright, we have 1 final test, we will create a letters array with multiple instances of 1 letter, and then have the @letter_guessed be that letter, then return the final place_letter_hash, to see if we get all the isntances of the letter, both upcase and downcase, and their correct indices.

Good that worked perfectly. The final hash has our letter element as the key, with the correct index as its value, so now we just have to access this hash and set each key equal to its index value corresponding to word board coordinate. What is the relationship between the hash and the word board again? Our board array is @board[][], where the first coordinate is our hash key, and the second coordinate is always 0. So... "@board[hash_value][0] = hash_key". Wow, we're on a roll. That code worked too. The like last 5 little functions we coded all pretty much worked the way we wanted them to work, kinda surprising bc we've been slogging through pretty much every assignment. Let's try to test this out in the bigger code before we move on. Hmmm.. we are getting a invalid method for 'each_with_index'. We look at our code and the letters_array calls that method, from the Board class. Maybe our Board class can't access the letters array since it was created in the Game class? Let's move our place_letter function into the Game class and see if that resolves our issue. If it does, it probably means that @letters_array is restricted since it was created in another class. Everything was going well until we get to the end and try to set the board coordinate equal to the key, we get this error "undefined method `[]' for #<Board:0x0000565434fe7bb0>)". We can't access @board or what? In our test code, we set @board equal to the array. Wait a minute, when we type in our "game" object, we see 2 instances of @board, one with the strings of letters and numbers, and one that displays our arrays. Did we accidentally create 2 @boards? Let's review the tic tac toe code again. The code is the exact same as tictactoe in regards to how many @boards we initialize and where they are created, so I'm not sure why it gave us an undefinied method for @board. Maybe there was something with a previous code in there. We're gonna compile the same thing on a fresh terminal and see. The only other difference is we didn't run everything in the initialize function, which reminds us, we're gonna have to create a play function that loops through all these functions.

Hmmm, we're getting the same rejection for @board. Let's type in @board and see what it outputs? Yeah nothing bc it's inside the class and restricted. Alright, let's try creating this "play" function and putting our functions in there. That's one difference we saw between the tictactoe code and ours. Lol, we got a compiling error trying to use "loop.do" I think. The code in tictactoe is "loop do". Yeah, now the loop seemed to work but, we got stopped still at the @board thing. Why don't we remove the Board class initialize, and just run the Game class initialize. We don't really need any properties from the Board class? Wait a minute, without a board item, we can't call @board.render. Let's create a new board item in the Game class initialize and remove the initialize from the Board class, we can still do everything we want here, but it seems there might be 2 instances of @board? Hmmm... that's not working. What if we remove the board class entirely? If we move render to the game class, then we don't need the board object to call it. Ok, this does work, but that means we don't have a Board class now. We need to test the place_letter function with this code now. We got an error bc we can't change the letter guessed outside of the class it seems. 

Another way to solve this, was to keep everything we originally had, but in the place_letter function, put a parameter to pass through our letters_array? Let's try that. Lol after like 10 mins it's done and we get an error for not using our parameter in "place_letter" function. Try again. We still get undefined method lol. We just realized we forgot to call it from the @board object, let's try once more lol. Ok, this time things are going well. Then we run into a letter in the word, and get an error for "each_with_index" just like before we added a parameter. We realized we used "@letters_array" instead of our parameter "letters_array" inside the "place_letter" function, so let's try this again. Now we get undefined "upcase" and looking at our code, it seems @letter_guessed isn't defined either, let's add that as a parameter as well. Omg it finally worked lol. Let's think about this. So there are 2 @boards, which kind of makes sense now that we think about it. One is initialized in the Board class, and one is initialized in the Game class. The @board in the game class is just used to call the render function, and now the place_letter function, but the @board in the Board class is actually the array. I think we were trying to call @board, wanting to target the array, but getting the board object, they are indeed 2 different things. Having multiple classes does complicate things quite a bit, but it helps with organization too. I guess it's good to learn these little quirks of class access now. We haven't checked our play function for non letter inputs and string inputs, so make sure to do that next time we compile.

Ok, now what do we need to do? Reviewing our prior pseudocode, it looks like we still need a boolean denoting whether the letter guessed was right or wrong. Regardless of this, we'll update the "letter_guessed_display" to add our guessed letter. If the letter guessed was right, we should display some message saying so, then place the letter using our place_letter function. If the letter guessed is wrong, we'll need to tick down our "number_of_guesses_left_display" and display some message saying the guess is incorrect. Actually our function "letter_in_word?" is already the boolean that we want to know if the guess is correct, so put a message saying the letter is in word in that. Yeah, we can do confirmations of letter being in word inside "letter_in_word?", and also update all the visual displays as well. Now, how are we gonna manage the visual displays? Are they gonna be objects? Or just puts? I'm thinking the letters_guessed display will be an array that we update, then just convert to string and display with a puts? The "number_of_guesses_left" display can be tracked with a number_of_guesses_left counter that we tick down, then displayed with a puts I'd say.

As we're adding the code for the letters guessed array, we realize that we don't want them to guess a letter that they already guessed, so we're gonna need a check for that as well, and add an error message. Alright so now we're compiling. We added quite a bit of code, so here's the things to debug for when testing. First off we didn't test nonsense inputs in our first test, so test number inputs and long string inputs to make sure the code is doing what we want. Then, we added the @letters_guessed_array so make sure that's working properly. Next, we have a new boolean check "letter_already_guessed" so make sure we give answers that test the function for both true and false. This function is where we add the guessed letter to our array, so make sure that's working properly. We still need to convert this array into a display so that the user knows what they've guessed and how many guesses they have left. I like displaying this info with the board.render right before the _ask_player_for_letter function. It doesn't even compile lol. We get a undefined variable. Looking over our code, we find that we used "letters_guessed_array" instead of "@letters_guessed_array" inside our "letter_already_guessed?" function, so we're gonna fix that. Now, while it was compiling we added even more code. We add another thing to the initilize of the Game class, a "@number_of_guesses_counter = 8" to keep track of how many guesses the player has left. We also updated our play function to render the board and display both the letters_guessed and the number_of_guesses_left before asking the player for a letter. 

Lol, we guessed the letter "p", but it didn't update in the letters guessed array, nor did the number_of_guesses counter tick down. We also guessed a correct letter "a" in the word, but nothing happened lol. WTF. Maybe we shoulda tried to test these things one by one, but it's taking like 5 to 10 mins each time to compile ugh. We tried calling the "play" function again but yeah, these 3 things are not happenning: a) @letters_guessed_array not updating when valid letters are guessed b) the number of guesses counter not ticking down after each wrong guess c) the right guesses are not calling the place_letter function. Alright, let's isolate this letter_aleady_guessed? function and see why it's not updating the array. Ok, it looks like the code is stopping short bc of the return true part of it. We've seen this before. Ah yes, I think i remember now... We have to take the return false out of the else statement, bc that will stop the loop. Put the return false outside the loop, so that it loops through all the letters. Ok, so that works now. Now, let's look at the number of guesses counter. This code looks fine lol, but we'll print out the @number_of_guesses_left counter to make sure it's updating correctly. Lol, it didn't compile bc we forgot an "@" before letter_guessed. Not sure why this compiled before if this code was like this. Alright, that seemed to fix things. We're gonna put back these 2 functions into the main code and run the whole thing again. I think that for the third issue, about the correct guesses not updating the board, that's probably more to do with our first function "letter_already_guessed?" and how that was cutting short, so maybe the loops weren't able to fully run. Looking over our play code, both the "letter_already_guessed?" function and the "word_is_valid?" function are run before we call "place_piece", so yeah, they are probably causing that function to not run and update the board.

Hmmm... the letters_guessed_array is still not updating. Maybe it's not accounting for a blank array? Test the blank array in the test function. Alright, moving on to other tests. Our numbers input test worked. It gave us the proper error message and the guesses counter didn't go down. Long strings also gave the appropriate error and kept the guesses counter from changing. All the other tests seem fine, but this letters array is still not working. We almost forgot to test the correct guesses. Guessing the correct letter does update the board and give the proper message now, so that's good. Actually test this "letters_guessed_array" as an empty array to see if we can replicate the problem. Hmmm.. it seems our code works fine if something is in the array, but as an empty array, nothing is being added to it. Let's add an if statement that if length of array equals 0, to add the letter guessed? Ok, that seemed to work. We put the letter z into an empty array, and it printed z for the array, and returned false. Let's run the big code again. So, what are we checking now? Pretty much anything that involves the "letters_guessed_array". We want to make sure it's updating correctly, and that other functions that rely on the array are working as intended. Ok, so we get a big random word with 12 letters. Our first guess was correct, and it updated the board, and the letters_guessed_array, which is good. Then we guessed a capital T, and it said we already guessed that letter. There must be some logic order problems bc that was our second guess lol. We're gonna put a puts before the loop through our letters guessed array, and a puts after our loop, for the letters guessed array to see why it thinks a letter we just guessed has already been guessed. Lol, the code took about 15 mins to compile, and then we realized that we forgot the @ in the puts statement. Guess we'll try this again lol.

I think we found the problem, and it is with our code. We have an if else statement, so if the letter doesn't match a letter in the array, it adds it to the array. We didn't catch this before bc the array was empty, so the code never actually ran but, this logic is wrong. We want to add the letter after we perform the loop, so put it outside and after the loop. We've made this mistake a couple times while writing these loops, so make sure we understand the logic of these loops when we are writing them. It's funny bc the first similar loop today we did it right, bc we remembered doing this wrong before, but I think we're getting a little worn out and just autopilot coding now lol. Ok, so we move the adding of the letter to the array to the outside of the loop, then we don't actually need the if statement to check if it's empty or not right? Regardless if the array is empty or not, we will be adding the letter to the array, since it is a valid letter, and hasn't been already guessed. Ok, good, now it seems this letters_guessed_array works. Let's test with a duplicate letter now and see what happens. Ok, good, doing a duplicate letter resulted in the duplicate letter message and didn't tick down our guesses counter. 

We noticed another bug when we were testing. Our mystery word had 2 "r"s, but the board only recognized place down 1 r, which is weird bc we've tested this code and it worked before from what we remember. Alright, we've put a puts to display the place_letter_hash before its loop. It seemed like in the code that the keys and values were being added properly, but only 1 item in the hash was enumerated? Maybe something got cut short, or the hash is actually wrong, which is why we added the puts to display the hash. We've also hardcoded a word with multiple instances to make sure we test if it's handling words with multiples of the same letter correctly. Looking over the results of after it compiled, we realized what happened. Hashes can not have multiple keys of the same value, so if we wanted to code it like this, then the keys needed to be the index, bc those will not repeat, and the values should have been the letters. We have to remember when we're doing a hash, that the keys can not be the same values, and pick the variables for keys and values with that concept in mind. Lol, wtf, why is the code taking so long this time, so weird. Ok, so that fixed that problem. That was quite a bit of debugging, which was really slowed down by the compiling times.

Currently our "letters_guessed" display is an array, which looks odd. Can we convert that to a string when displaying it to make it look better? Afterwards, we can make a check for the game ending. We can check if there are no guesses left, and display that the player has lost. We can also check if all the letters on the word board are filled out, and display a message that the player has won. Alright, so the method to make an array to a string is "join" with a parameter for the spacing that we want, which will be a comma, so let's isolate the code and try it. Alright we isolated and tested that code, so it should work in the bigger code. It'll be tested when we compile next anyway, bc it pops up during the play loop.

Let's write a check to see if there are no guesses left. It looks like we already have a placeholder for this check guess count code in our play count counter, we just need to replace that check with the check for the guesses left. Ok, that was pretty simple since we had the logic set up in our loop already. It's just a simple puts to declare a loser, so we won't test it now. Now the winning combination check... How do we check if all the letters of the word board are guessed correctly. I think we want to iterate though our board array, just like we iterate through the arrays to create underscores, I think we can use the same logic. Note that while this should be a Game class logic, it's in the board logic so we can iterate through the @board array. Before we try a loop through our array, we had an idea of just to check each board coordinate separately, which isn't exactly easy bc the board length is variable and depends on the word length. Actually im not sure how to code this loop lol. How do we check if all values are nil or not. I think it's just alot easier to read to pick every specific coordinate. If we are going to use this "game_over?" from the Board class, then we're gonna need to put in parameters so that we can access the variables that we want from the Game class. Wait a minute, we are just checking if the board coordinates are nil or not, do we need variables? Yeah, we're gonna need @word.length to know what coordinates to check. As we're coding this, we realize it's also very ineloquent. The fact that the word length is variable, and thus the board is of a variable size, makes checking each board coordinate not easy. However, we already have something that can track the letters and progress towards all the letters of the mystery word being guessed, and that is our letters_array. Why don't we delete these letters as they are guessed, then when there are no more letters left to guess, so when the array is empty, that results in a win.

A thought occurred as we were doing that. Why not use our board coordinates to check, but instead of putting in individual coordinates, we use a range, up to our word.length? Does this work? Hmmm.. it keeps saying [] is an undefined method. Let's define an array within an array similar to our @board array, then try to call its coordinates with a range. Hmmm, @board[0..4][0] doesn't give us all the coordinates from [0][0] to [4][0], but @board[0..4] does give us "[[0], [1], [2], [3], [4]]" which seems like a workable start. Since we have a range, can't we just use a loop and tick up until we hit that range? I think we can do this, but this code seems unnecessarily complicated for no reason. Let's just use a replica of our letters_array (bc we need the original for letter position), and remove letter elements as we guess the letters. Let's go into our code and see where the letters are placed, then in the same function, destroy those letters in our replica letters array. We can use "Array.delete_at(index)" method to remove our elements at their index... hmmm... actually we can't bc the index will change once the array starts getting deleted... we need a method that looks for specific elements and removes them. Lmao, for such a simple task, google is being pretty confusing. Apparently there is a "remove" method as well, but not sure if for only strings, or we can use for an array. Let's just create a test array and test it out. Interesting, "remove" in undefined, so probably only for strings then, even though a stackoverflow post had the poster using it for arrays it seemed. Let's try "delete". Interesting, so "delete" is the function we want to use for arrays. It seems delete will return the removed element, and is also destructive to the original array. One more thing to note, if 2 letters have different cases (upcase and downcase), it will not remove both, only whatever case we put in for the letter element.

Ok, while we are compiling to need to make notes of what to check for, as we've made quite a few changes. 1) we've added a "@letters_remaining_array", which keeps track of the letters we need to guess, and we will check if it's empty to determine if we have won 2) along the same line as point #1, we have a "game_over?" function now, so make sure we check if both true and false statements work and it displays the proper message; also make sure we have the correct parameters for the function and the function call, as that seems like a common error 3) inside the place letter function, we've added additional code to delete the elements that match our letters array, so make sure that's working properly and that the letters remaining array is correct before and after deletion 4) inside our play function, we've added some more code a) the letters guessed display has changed from an array to a string, so make sure that looks good b) we added a guesses left counter check, that when the counter is at 0, displays a losing message to the player, so get the counter to 0 and make sure that goes off c) we also have the game_over? function here, so make sure that when we guess all the correct letters, we get the appropriate game over message.

Interesting, we are getting an undefined method game_over? for board, and as we think about it, we realized what happenned. We initially set the game_over function to be in the Board class to have access to the array board, but now that we don't check the array anymore, calling @board from the Board class, which is the @board that is an array object, doesn't work. Ok, so we're gonna move our game_over? function to the Game class, remove it's parameter bc we can now call letters_remaining_array with @letters_remaining_array, then change the way it's called in the play function, since we don't need the board object to call it anymore. I like this change to the game over function, as we really don't want the board class to call a game over function as it is. Looking at what we have so far, we see something else. We have a puts that displays the number of guesses counter, and one that displays that we didn't get a correct letter, but the number of guesses is displayed before the message that we guessed wrong, which is obviously backwards. However, I think we just put this puts in as a debug to check and make sure our code is running fine. It looks like it is, so we can just remove it. Let's place it on underneath for now though, bc we aren't done debugging this part.

Alright, let's recompile and check everything 2 paragraphs above, and also make sure the fix to our game_over function worked. Letters remaining array seems correct and updating when we get a letter correct. The delete code seems to be working correctly, as the letters remaining array is correct before and after deletion. The letters guessed display looks alot better as a string than an array. The number of guesses left display looks good and is updating appropriately. As we're testing the game_over function, we see that the letters filling in don'nt have a space next to them, and that makes the board look weird, we have to make sure to return the letter as a string with a space after it. Ok, so it looks like our game over check is working properly. When all the letters are guessed, we get the puts to that we've won, but... we didn't display the winning board, so add code to display the winning board, yeah just render the board before. Actually i'm not sure we want to remove this spacing problem, is it really a problem? Do we want the letters mushed in together when the word starts getting solved? Before we move on, I think we should render the board in a loss too.

Alright, so while we're compiling let's talk about the changes we made. 1) in order to add spaces to letters on the board, we've changed this code "@board[key][0] = value" into this "@board[key][0] = '#{value} '", wrapping quotes around our value variable so we can add an additional space 2) We've added "board.render" to all the "break"s in the play function, which includes winning the game and losing the game. We feel it's pertinent to display the game board when it's over, just so the player can reflect on the game a bit, and see where things went wrong and right, see how close or not close they were to guessing the word. Actually, now that we mention this, I think displaying the letters guessed here would be good too? Yeah, the things that are displayed every question, i.e. the letters guessed and the board, should be displayed at the end, we're gonna update this for the next compile, also, we want a space between these messages and the one saying that the game was won or lost, so put en empty "puts" between the puts 3) We need to test the losing condition now, or when we run out of guesses. Also in this losing condition, do some integer and string guesses to make sure everything is working properly for nonsense inputs.

Ok, good, the spaces seem to be showing up in our board now with the new code and the board looks better with letters filled in than before. Ok, so the game did end when we ran out of guesses, and we got the error message, so that was good. It was a good idea to show the board before displaying the losing message, just as it's good to see the board when we get the winning message. We can test again and this time check if our additional messages when the game is over are appropriate, that there's a space between those messages and the winning/losing message, and that no more debugging prints or puts show up in our almost finished code. Alright, that looked really good. All the messages that showed at the end, including the board, are a good conclusion to the game. The player can look at those and reflect on what happened in the game. The spacing of the winning/losing message is good, it separates the scoreboard from the actual game is won/lost message. I think we've removed all the debugging prints and puts now, so the command line has only relevant puts for the player.

So it looks like we are actually done with the game coding part of this assignment, since everything seems to be working well. However, there is more to this project. We need to create the option for the player at beginning of the turn to save the game, then actually save the game state and be able to reload it at next game's open.

Ok, so how do we save the game state. Apparently this was during the serialization parts of the reading, but we really didn't get much from those readings. First, we're gonna need to make a save game option at the beginning of the play loop. Alright, that was pretty simple, we just puts out a question to ask player if they want to save, then keep the answer in an "answer" variable, then check if the answer is equal to a "Yes" or "YES" string, and if so, save the game. If the answer is anything else we'll take that as a no and continue the game. Actually we're gonna change the puts to "type 'save' to save the current game" and look for answer strings of "save", "Save", and "SAVE". Typing save just seems better than typing yes to us.

Alright, so how exactly are we gonna save our game? So we've looked at our past lesson about serialization, but didn't like it, so tried to google more stuff about saving games. I'll guess we'll try the YAML method outlined in one of the readings. We want to use JSON bc it sounds like that might be more widely used, but YAML is apparently easier to use, so let's go with that. So we're looking at this YAML serializing description again, and what is it actually saving? What should we be saving. Theoretically, we should just be saving the objects that need to be saved in the game, such as the @board object. Going in, we thought we'd be saving our whole file, just changing to a string. There's nothing in the readings that tell you what objects are relevant in your game to save, which makes this tricky. Looking back at the assignment, it does remind us we can serialize our entire Game class, which sounds like pretty much our whole file, which is why we thought we'd just be saving all our code. But... what does it mean to save the "Game" class? That's just code that operates our Game class, but the changes to the board and the mystery word and such, our code doesn't keep track of those right? Man, the assignment is really lacking in direction. I'm not sure how exactly to save our game status. I guess we'll just have to do it by trial and error. 

So... let's brainstorm. What objects have important data that need to be saved? I think every instance variable that we created in the Game class' initialize function is important and needs to be saved. Looking over our code, I think with all of these variables, we can recreate any game state. Ok, so now, how do we save these objects? Let's start by trying to save one object, and loading it, and seeing what happens. Then if that works out, we can save and load the rest and test if those are all the variables necessary or not. Alright, so at the very top of our code, we need a "require 'yaml'" then we'll use this code "serialized_object = YAML::dump(c) puts serialized_object" where the object is after "dump", inside the parameter. Then, to retrieve our object we'll use "puts YAML::load(serialized_object)"

Ok, let's try this with our first object, which is @word. (Don't forget we also have an @board in the Board class as well). Actually, those triple backticks aren't part of the code I don't think, he's just using them to output text in ruby format, I think that's what that means. Ok, we've removed the ruby and triple backticks from the above code to match this idea. Let's test the saving and loading in terminal before putting it into our function actually. Ok so testing this code "serialized_object = YAML::dump(c) puts serialized_object" this code "puts YAML::load(serialized_object)" shows that the info is being saved under that variable. The "c" variable in question here was our @word variable, and it did bring back the value of the variable when we went to retrieve it. However, if we change the variable after saving it, then go to retrieve it, it's still the same value. We were expecting since it was some saved value, it would go back to the saved value, not the new value set. I think we can solve this by just setting the values to the saved values when we load the game? Isn't that the point, to keep the old values? Let's try changing the @word, then setting it to the saved value, and see what displays. Ok, yeah, that does work. So, when we save, we save all these instance variables, then when we load, we set our instance variables equal to the saved values? That seems logical... One thing we can see being a problem is where are we saving these files? We aren't specifying some area in the hard drive to save, so will they even be saved after we close terminal and then reopen? Let's test that.

One thing we thought about yesterday is, if we can save a variable, or object, why not just save our game object that we create for the game outside of all the classes. That should have all our data? Let's try saving the word and reloading, then saving the game and reloading. Ok, so we want to test this, but on a smaller scale, how do we do it? Ok, so the first variable we want to test is @word. Let's get an @word saved, then load it in the initialize. Interesting, when we try to run our save game function, it says "serialized object not defined". Rerunning the code, we notice that even if we change our @word to a different word, when we type in the game object, it shows the old word. So maybe the game object is what we want to save? Let's just try to save the word and load it i guess. It doesn't seem like we access "serialized object" since we create it in another function? Let's just did what we did yesterday and put the code outside all the classes. Then let's close and reopen terminal and see if @word was saved or not. I don't think our current code is able to test this. Let's not put anything in the initialize, then have a function that has the word as 1 thing, and another function to change that word, then reload terminal and see if anything saves.

Interesting, so using our name changing function does change the @word to a different name, and that shows up in the @word object. However, the game object of the Game class isn't correlated with the @word object apparently. If we manually set @word to some name, it will stay there, but the game object still has the @word set to whatever we set it with the @word changing function. Ok, so we load our new terminal, and after we compile our code, we check for @word, which it says is nil. We check game and it says game is undefined, which is good too I guess. Then we create our game again "game= Game.new" and type in the game object, which shows nothing. Ok, it doesn't seem like we saved anything, which kind of makes sense bc this info wasn't saved on the hard drive anywhere. How do we actually save these variables/objects into our hard drive for recall later?

We found a stackoverflow post that talks about saving games and loading them, so let's try that method. The code used to save a game was "File.open("./asciitrails.yml", 'w') { |f| YAML.dump([] << self, f) }
exit" and the game load code was "
begin
   yaml = YAML.load_file("./asciitrails.yml")
   @history = yaml[0].history
rescue
   @history = []
end". Let's try these lines of code and see what happens, but using our own files. I think the name for our hangman file is... "/home/xmrmisterx/the_odin_project/hangman/hangman.rb". Ok, I don't think this is what we want to do though. That is our current file, and we definitely don't want to overwrite that. We can make a similar file, maybe a 'yaml' file, something like "savedgame.yaml", and it will write or create into that file, but definitely don't overwrite our current file lol. OK, so this is more about opening files and serialization than about ruby and yaml, so let's read a little more into it. There is a vikingcodeschool page about reading files, and so far it's been pretty useful. If we look back at our 5desk.txt, we see that we opened that file, so how did we do that? We used "File.read'filename', so we'll definitely be using this File class to write and read. Writing a file, and reading a file, are like 2 sides of the same coin, they both require the file class, just using different methods and the flow of information is opposite. So... with this knowledge, how would we save our file? Remember, we have to do it into yaml. Before we move on, vikingscodeschool goes on to talk about what we should be saving. An entire class instance, or just bits of it, and says that it is variable. We're leaning towards saving the game object, as it should have all the relevant variables we need for our game. 

Alright, so let's start off small. Let's try saving @word, closing terminal, and load that data back... Vikingcodeschool had a very eloquent example of saving and loading with yaml, so let's try that out. The saving code is "my_yaml_instance = some_instance.to_yaml" and the loading code is "YAML.load(my_yaml_instance)", so let's try them out. Wait a minute, didn't we already do something like this? It works, but the data doesn't persist when we close terminal and open it back up, so we can't use this. Actually, I think this code from vikingcodeschool is what we're looking for "
> require 'json'
#=> true

# Our character from the game
> my_hash = {:name => "Dolph", :age => 21}
#=> {:name => "Dolph", :age => 21}

# Write (or overwrite) our character to `saved_hash.txt`
> File.open("saved_hash.txt","w") do |file|
>     file.write my_hash.to_json
> end
#=> 25

# Check that our file looks right
> File.read("saved_hash.txt")
#=> "{\"name\":\"Dolph\",\"age\":21}" 

# Bring the object back into Ruby
> my_saved_hash = JSON.parse(File.read("saved_hash.txt"))
# => {"name"=>"Dolph", "age"=>21}
"
Even though this is a JSON example, I think the notation is very similar to YAML and the concept is the same. We have to open up a file, giving it whatever file path we want, then write our object that's been converted into json or yaml. Then, when we open it, we have to open the file, parse it, and set it to a variable I guess. Do we even have to parse with YAML, maybe not. We read the 5desk.txt without parsing. Alright so let's try this code now. I think we're gonna have to initialize our test Game class to set @word to an empty string so that things make sense here. Ok, so we finish compiling, and our @word is currently nil. We use our name change function to change @word to mike. We type in the "game" object and it shows @word is now mike, and when we type in "@word" in terminal, it is still nil. So far, things are working as expected. Now, let's save our @word, then test reading the output, then create a load option and redo the first steps, but after saving, we need to open up a fresh terminal and see if we can load the saved @word. Ohhh... our save game function created a new txt file called "savedgame.txt", which is the path that we chose for our saved game. Pretty cool how it pops up like that lol. Now, let's use "File.read("savedgame.txt")" to see if the output is correct, even though we can click on this txt file and see that it is correct. We get an output of "'--- mike\n'", so that looks good. Now, let's try adding a load game function and see if we can load this back up on a brand new terminal. We ended up with this code to load our object "saved_game = YAML.load_file("savedgame.txt")". Honestly it wasn't that clear that this code even works, as our vikingcodeschool example is a "JSON.parse" example, and our stackoverflow question has some weird "@history" variable in it, which we're not sure if correct/current, so we're gonna try this code which we kinda just made up, but should work.

Alright, so before we even create our "game" object to run the game, let's try to load the game. Actually, we need an object to call load game, bc it's in our game class lol, unless we make it a class object, which we probably should have done in hindsight, that way we can load games, before creating a game. Anyways, let's follow through by creating our game object, calling load game, and seeing if it loads the file. Before loading the file, see what @word is first. And what our game object is, then after loading check and see. Ok, so right after we create our game object, we check it, and it displays an empty string for @word. Typing "@word" in the console shows nil. Now, let's load the file. Ok, so our object "mike" did show up when we loaded the file, but the game object and @word are still the same. We need to set in our load game code that @word = saved_game, but yeah, we don't want to save the instance variable, we'd have to save them all, and so I think for this hangman game, saving our game object is what we want to do. Let's change our load_game code to update @word and see if it works though. There we go. So when we tested game it showed an empty string, and when we tested @word it was nil. Then we called "load_game", and afterwards, game showed that @word was mike, and when we typed in @word, it was nil. So that is pretty cool. We were able to recall our saved game object, even after closing down terminal.

Now, let's try to save our "game" object, so put back all the instance variables in the game initialize, create some functions to change those values, run those functions, then save the game, close terminal, compile the code again and "load_game", then call our "game" object again and make sure all the objects in the initialize have the saved values. Ugh, we need to update the save and load game functions first, to save the "game" object, then to load the "game" object. Wait a minute, we can't use the same code format, bc @word is an instance variable, whereas "game" is a class object. How do we even save it? It can't be a instance variable, so our save and load game functions need to be class functions right? They should be class functions with parameters, that parameter being the game to save or load. The save game function seems pretty easy, we put our game object in as a parameter and save that. However, the load game, before we set the instance of the variable to the value saved, but what do we set our saved game file equal to? Maybe we can use this code "game = Game.new" then "game = saved_game"? Let's try that I guess. Since there is only 1 saved game file, and we hardcode the file path, there's no reason for a game parameter in the load game function it seems? Alright let's just try it and see how it goes. 

Alright, so we do everything, and call the load game function, and it does load our game object, but when we try to type "game" to see what the game object is, it says undefined variable or method. Why don't instead of creating a game variable inside our load game function, we do the same thing with every compile, we create a new game object "game = Game.new". Then, we use a variable on the load_game function for this game object, and set it equal to our saved game object. That should theoretically have our game object, and hopefully we can just continue from there. While it's compiling, we had a thought. If we have the "game" object created before anything else, then there's no reason to make our load game and save game functions class function, since we have the game object to call regular functions with. Also, what about continuing to play our game, changing the variables more, then loading the game as we're playing. Can we do that? Why are we closing terminal everytime before loading a game? I think we just did that to test if it saved on the hard drive, which we've already confirmed. Yeah, we can test and see if we can continue playing, then call load game and go back to a previous saved version. We can also save a game, then load it right away (which shouldn't do anything, but it's something to test)

Ok, so it's done compiling, and we load the game, then we type in "game", and get our initialized "game" with all the variables being blank. I think what we need to do... is return our game object in load_game, and specifically set the "game" object we create at the beginning of the game, equal to our load game function? Let's also change our methods to regular methods as well. We're gonna rename our load game function saved game for more clarity. Ok, so that worked, setting our "game" object to our saved game function outside of the functions worked "game = game.saved_game". Now what? Let's try what we were talking about before, change up some variable, then load the game and see if it overrides it. Ok, so currently our @word is john, we're gonna change @word to mike, then load the previous game and make sure it goes back to john. Cool that worked, it went back to john when we loaded the game. Now... let's change it to mike, save it, then change it back to john, then load the saved game and see if it goes back to mike. Ok, yeah, so that worked. Very cool, I wonder why we can't send our game object in and change it, but coding it outside the object isn't that bad either. We need to test these functions in the main code, but they seem to work fine in testing. Let's add these methods to the main code, then add some puts in the beginning of our game allowing for loading games.

Ok, when adding the code back to the main class, we realized that our game parameter in our save_game function isn't actually anywhere in our ask_player_to_save code, so we have to add the game parameter to the ask_player_to_save code as well. Lol, we realized that when we put the ask_player_to_save in the play loop, that our game object isn't in this either, so we have to put the "game" object as a parameter in our "play" function was well. Can't we just make it an instance variable and set it to our "game" object? I don't think we can lol. This seems so ineloquent. There must be a better way to do this? Let's try initializing a @game object, which requires that our Game class initialize have a parameter for game, but this is much more eloquent than putting the game parameter everywhere. Wait a minute, so we set our @game object equal to game, then what happens when we try to save it? Do we need to update our @game object first? Then what happens when we call save game? Don't we still need a parameter for our "game" object? Let's just pass our game object I guess. Hold up, let's test this out in sample code. Set game equal to tetris, set @game = game, then set game equal to mario, what is @game? @game is still tetris... yeah, if we don't update the instance variable, it means nothing. Let's just bring in the "game" object as a parameter I guess.

Ok, so we changed quite a few things, so let's test them out... 1) We added the "save_game" function, so make sure that works right, and that the parameter is our actual "game" object 2) We have a "saved_game" function, which is the pathfile to our saved "game" object, so make sure that recalls the correct thing 3) We put the "save_game" function into our "ask_player_to_save" function, which we've renamed "ask_to_save_game" function, and included a game parameter into this function, so make sure the parameter is working and function working as intended 4) We've inserted our "ask_to_save_game" function into the play loop, so make sure that function is inserted at a logical spot, and we've also added a game parameter to our play function, so make sure that's working still 5) We added a "ask_to_load_game" function, which also has the game parameter, so make sure that's working properly. We've added it to the beginning of the game, so make sure the game flow makes sense when asking to load and save 6) Finally, if everything is working correctly, we want to test the load and save game functions a) save a game, then close terminal and try to load it b) after loading game, change the "game" object variables, and load back to saved game while in the same terminal session c) load a game, change the game variables, save it, change the variables again, then load the last saved game, all in the same terminal session (make sure all the variables are loaded and saved correctly)

The ask to save game function in the play loop seems fine, it's in a logical spot, albeit annoying bc it pops up after every guess. The load game option does come up at the beginning (after we remembered to call our game object with a Game class initialize now "game = Game.new(game))". When we saved our game, it worked with the "save" answer, however, we have a puts that says "saving game" after the game is already saved, which is kinda pointless, so we change that puts to "game saved." Ok, so comparing our saved game to the current game, it looks like it saved perfectly. Now, let's play to the end, then try the load game function. Ok, so the load game responded to our "load" input but... it didn't automatically continue that game, we need to continue the game in the code... So we typed in "game.play(game)" which started our finished game again, so that's not what we wanted. I think maybe bc we're calling "game" outside of the "load_game" function, that it didn't take, but after we load the game, it should start things with the saved games instance variable values. Let's recompile the code with this updated version.

Ok, so when this is done compiling, check to make sure after saving a game, then loading it, that we are playing the loaded game with the loaded variables. Do the same thing like last time and lose the game to get back into terminal input, then load the game. If this works properly now, do test point #6 from above, then we are done with this hangman project. Ok, so this time, we were able to continue our game, which means the problem was that we didn't call our game object from inside the load game function, which we kinda thought was the issue. Ok, so now we test point 6 above. We were able to test b and c from the current file, but let's recompile and test a, loading of the game from a fresh terminal. Alright, looks like test a is good, I think we are done now.






``` ruby
require "yaml" #  We do this to access yaml, which is used to save our game.

class Game # We have 2 classes, a Game class, and a Board class. The Game class deals with all the game related functions and objects, while the Board class handles the board display and board functions.

  def initialize (game) # We initialize a game object with a "game" parameter. This is our way of moving our "game" object around, mainly so that we can use it as a parameter to save the game.
  @word = choose_random_word("5desk.txt") # We call our choose random word function to choose a random word from the text file, then set it to @word. We need an @word instance variable so that we can access @word inside our other Game functions without having to bring it in as a parameter everytime.
  @board = Board.new(@word.length) # We also need an instance variable for the board...
  @letter_guessed = "" # and letter guessed.
  @letters_array = @word.chars # we want to break our word into a characters array called letters array, so that we can compare the letter guessed to this letters array, to see if the player guessed correctly or not.
  @letters_remaining_array = @word.chars # we have a separate array for the letters remaining in our word after every guess. Note that this array and the letters array start off having the same values, but this array's elements will be destroyed as the player guesses more and more correct letters, eventually leading to an empty array which signals that the game is over.
  @letters_guessed_array = [] # we also have a letters guessed array that keeps track of the letters that the player has guessed, which is then used to display the letters guessed to the player
  @number_of_guesses_counter = 8 # the rules of this game include being able to guess only 8 times, so we have a number of guesses counter set to 8, which will tick down after every wrong letter guessed
  
  end

  def play(game) # This is our play loop that will keep asking the player for letters to guess until they guess all the letters, or run out of guesses. Note there is a game object parameter in this function, which is used when saving and loading our game object.
    loop do # Our play loop consists of a display that...
      @board.render # shows the missing letters of the word...
      puts "Letters guessed: #{@letters_guessed_array.join(",")}" # displays the letters guessed... (Here we convert our letters guessed array into a string for more readability)
      puts "Number of guesses left: #{@number_of_guesses_counter}" # and displays the number of guesses left.
      ask_to_save_game(game) # we have an ask to save game function before each guess, per assigment directions.
      ask_player_for_letter # this function asks player for a letter...
      if valid_letter? # if the letter is valid, that is, if it's an actual letter and not a number, other character, or a string...
        if letter_already_guessed? == false # if the letter hasn't been guessed already...
          if letter_in_word? # if the letter is in our mystery word...
            @board.place_letter(@letters_array, @letter_guessed, @letters_remaining_array) # then place the letter(s) onto the board. Because place_letter is a Board function, we have to use parameters for this function in order to reference the relevant variables from our Game class.
          end
        end
      end
      if @number_of_guesses_counter <= 0 # If out of guesses, display the board displays, then puts out a message that the player has lost the game. We use "break" at the end to break the play loop, since the game is over.
        @board.render
        puts "Letters guessed: #{@letters_guessed_array.join(",")}"
        puts "Number of guesses left: #{@number_of_guesses_counter}"
        puts
        puts "You have no more guesses left and have lost the game."
        break
      elsif game_over? # If the game is over, that is, the player has guessed all the missing letters, then display the board and puts out a winner message for the player
        @board.render
        puts "Letters guessed: #{@letters_guessed_array.join(",")}"
        puts "Number of guesses left: #{@number_of_guesses_counter}"
        puts
        puts "You guessed every letter in the mystery word and have won the game!"
        break
      end
    end
  end

  def create_words_array (txt) # This function creates a words array from our text file.
    words = File.read "#{txt}" # We use "file.read" to read the text file, and set it equal to a variable words...
    words.split("\r\n") # then we split each word up, and since each word in the text file is separated by "\r\n", we will split each word apart at that string.
  end

  def create_filtered_words_array (words_array) # We want to filter our words array only for the words that we want, which are words of 5 to 12 characters in length.
    words_array.select {|word| (5..12) === word.length} # From the words array in the parameter, select only the words that have a word length between a range of 5 to 12.
  end

  def choose_random_word (txt) # This is the main function we want to create from the previous functions. It combines the previous functions to pick a random word of 5 to 12 characters from our txt file.
    words_array = create_words_array(txt)
    filtered_words_array = create_filtered_words_array(words_array)
    filtered_words_array.sample # the "sample" method randomly picks 1 word from our filtered words array.
  end

  def ask_player_for_letter # We ask the player for a letter, then set the answer equal to our @letter variable.
    puts "Guess a letter from the mystery word..."
    @letter_guessed = gets.chomp

  end

  def valid_letter? # In order to determine if the player's input is a valid letter, we first...
    if @letter_guessed.length == 1 # make sure the input length is only 1...
      if (("a".."z") === @letter_guessed) || (("A".."Z") === @letter_guessed) # and that the input is between a through z. Here we use both the upper and lowercase versions of the alphabet, as we don't want the player's guesses to be case sensitive.
        return true # we return true, that the letter is valid, if the above 2 criteria are met
      else # otherwise, we give the player an error that the character is not a letter and return false
        puts "#{@letter_guessed} is not a letter..."
        return false
      end

    else # If the input has more than 1 character, we give an error message and return false, that the word is not valid.
      puts "Please input only one character for the letter..."
      return false
    end
  end

  def letter_already_guessed? # To check if the letter is already guessed, we iterate through our letters array...
    @letters_guessed_array.each do |letter|
      if (letter == @letter_guessed.upcase) || (letter == @letter_guessed.downcase) # and compare each letter in the array to our letter guessed, upper and lower cased versions of it.
        puts "You've already guessed that letter..."
        return true # If letter is already guessed, we display a message saying so, and return true
        
      end
      
    end
    @letters_guessed_array.push(@letter_guessed) # otherwise, if the letter is not already guessed, we add it to our letters guessed array, and return false.
    return false
  end


  def letter_in_word? # In order to determine if the letter is in the word...
    @letters_array.each do |character| # We take our letters array, which consists of the letters of our word, and iterate through it...
      if (character == @letter_guessed.upcase) || (character == @letter_guessed.downcase) # If a character in our letters array matches our letter guessed...
        puts "#{@letter_guessed} is in the mystery word!" # We say the letter guessed is correct, and return true
        return true
      end
    end
    @number_of_guesses_counter -= 1 # If the letter is not in the word, we tick down our number of guesses counter, display a message saying it isn't a letter in the word, then return false
    puts "#{@letter_guessed} is not part of the mystery word."
    return false
  end

  def game_over? # To check if the game is over, or that the player has won...

    if @letters_remaining_array.empty? # We check to see if the letters remaining array is empty or not. Remember that the letters remaining array has all the letters in our mystery word, and everytime a correct letter is guessed, that letter is removed from the array.
      return true
    else
      return false
    end
  end

  def ask_to_save_game(game) # The function to save our game involves asking the player if they want to save...
    puts "Type 'save' to save the current game."
    answer = gets.chomp
    if (answer == "save") || (answer == "Save") || (answer == "SAVE") # If they answer "save" in some manner, then we call the save game function. Note that both "ask to save game" and "save game" functions have the game object as a parameter. This lets us pass our game object through and save the current status of the game object and all the variables inside.
      save_game(game)

    else # If the player inputs anything besides save, we puts out a message that the game is continuing.
      puts "Continuing with the game..."
    end
  end

  def saved_game # We set a function equal to our saved game...
      YAML.load_file("savedgame.txt") # to load a file with yaml, we use "YAML.load_file" then put our file name in parantheses after that.
  end
  
  def save_game(game) # Our save game function, with the game object as a parameter so we can pass our current game object into it.
    puts "Game saved."
    File.open("savedgame.txt","w") do |file| # Here, we use "File.open" to open a file, then put our file name in parantheses, then the "w" to denote that we are writing into the file. If there is no file name at that path, it will create one. Next, we do a block for the file...
      file.write game.to_yaml # in which we "file.write" our object, which is the game object, ".to_yaml"
    end
  end

  def ask_to_load_game(game) # The load game function also has the game object as a parameter. When the program first starts, we create a game object in order to call our Game functions, so here we bring in the game object and set it equal to our "saved_game" game object.
    puts "Type 'load' to load previous game..." # We ask the player if they want to load a saved game.
    answer = gets.chomp
    if (answer == "load") || (answer == "LOAD") || (answer == "Load") # If the answer is 'load'...
      game = game.saved_game # we set our current game object equal to the "saved game" object...
      game.play(game) # then call the play function with our loaded game object to immediately continue playing from the loaded game state.
    else
      puts "Starting new game..." # If the player inputs anything but "load"...
      game.play(game) # we call the play loop with the game object created at the beginning of the program.
    end
  end

end

class Board # Our Board class handles the board and board functions.

  def initialize (word_length) # When we create a Board object, it needs the word_length parameter, since the number of missing letters on the board depends on how long the mystery word is.
    @board = Array.new(word_length) {Array.new(1)} # We create a board object, which is an array of word length in number of elements, and each element is itself a new array, with a nil element inside.
  end

  def render # This function displays our board, initially with all the missing letters, then has letters as the player guesses them correctly. The way our board works is that it's an array within an array, with nil elements by default. Each inner array represents one letter of the mystery word, and they all start off with nil elements until we put the letter inside them. Afterwords, they no longer have nil elements, but the string of a guessed letter inside the inner array.

    @board.each do |row| # We loop through each row in our board object...
      row.each do |cell| # and loop through each cell of the row...
        cell.nil? ? print("_ ") : print(cell.to_s) # to check if the cell is nil or if there's something there. If the cell is nil, we put an underscore there to represent a missing letter of the word. If the cell already has some string on it, that is, a letter is already there, we keep that letter. Note that our underscore has a space next to it "_ ", so the board doesn't look like 1 giant line, but rather multiple underscores separated by spaces.
      end

    end

    puts # This is a strange part of our code that we really don't understand, but somehow this "puts" allows our board to show up in the console. We know that puts creates a new line, so maybe that has something to do with it. Not sure but it works lol.

  end

  def place_letter (letters_array, letter_guessed, letters_remaining_array) # This function places the guessed letter(s) onto our board. Note that we need the letters array, letter guessed, and letters remaining array variables from the Game class in order to place a letter. We can't use the instance variables versions from the Game class itself bc instance variables can only be accessed inside the same class.
    place_letter_hash = {} # we have a temporary place_letter_hash here to keep track of the letter to index relationship between each letter in the letters array.
    letters_array.each_with_index do |letter, index| # We loop through our letters array (which is the characters from our mystery word)...
      if (letter == letter_guessed.upcase) || (letter == letter_guessed.downcase) # If the letter in the array matches the letter guessed...
        place_letter_hash [index] = letter # We create a new item in our hash with the index of that letter as the key, and letter string as the value linked to the key
        letters_remaining_array.delete(letter) # then we delete this letter from our letters remaining array, which signals that the letter was guessed correctly  and will be placed onto the board.

      end
    end

    place_letter_hash.each do |key, value| # then we loop through each item in our place letter hash...
      @board[key][0] = "#{value} " # and set the board coordinate at the key (which is a numerical index value) equal to the string value. Note that our board is an array within an array, and that the first letter is designated by @board[0][0], second letter is @board[1][0], third letter is @board[2][0], etc.
    end

  end

end

game = Game.new(game) # When we start our program, we create a new Game class object called "game", which has an initialize parameter of the "game" object itself, so that we can save and load the game.

game.ask_to_load_game(game) # Per the assignment, we need to ask the player if they want to load a saved game at the start of the game.



